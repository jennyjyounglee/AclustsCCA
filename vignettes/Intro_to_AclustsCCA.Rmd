---
title: "Introduction to AclustsCCA"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{IntroToAclustsCCA}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Installation

```{r, warning=F, message=F, eval=F}
devtools::install_github("https://github.com/jennyjyounglee/AclustsCCA")
library("AclustsCCA")
```


## Usage

Below is a list of input parameters:

1. Input data:
**`X``** \eqn{n} by \eqn{p} exposure data matrix, where \eqn{n} is sample size and \eqn{p} is number of exposures.
**`Y``** \eqn{n} by \eqn{q} outcome data matrix, where \eqn{n} is sample size and \eqn{q} is number of outcomes.
**`Z``** \eqn{n} by \eqn{e} confounder data matrix, where \eqn{n} is sample size and \eqn{r} is number of confounders. If `NULL`, partial residuals are used for SparseCCA analysis.
**`clusters.list`** A list of clusters with CpG sites obtained using A-clustering, each item is a cluster that contains a set of probes. A-clustering is implemented if `NULL` or can be provided by users.
**`annot`** A preloaded annotation file that includes columns "IlmnID", "Coordinate_37", "Islands_Name", "Relation_to_Island", "UCSC_RefGene_Name". Only needed if \cite{clusters.list} is `NULL`.


2. Input parameters associated with A-clustering:
**`dist.type`** A type of similarity distance function. Options are "spearman" (default), "pearson" (correlation measures) or "euclid". 
**`Aclust.method`** A type of clustering function. Options are "single", "complete" or "average" (default). 
**`thresh.dist`** A similarity distance threshold. Two neighboring clusters are merged to a single cluster if the similarity distance between them is above dist.thresh. Corresponds to $\bar{D}$ in the paper and the default is $0.2$
**`max.dist`** Optional maximum length between neighboring variables permitting to cluster them together. Corresponds to $\bar{d}_{bp}$ in the paper and the default is $1000$.
**`bp.thresh.dist`** A distance in chromosomal location. Any set of methylation sites within an interval smaller or equal to bp.dist will be potentially merged, depending on the similarity between sites at the ends of the interval. Corresponds to $\underline{d}_{bp}$ in the paper and the default is $999$.

3. Input parameters associated with SparseCCA:
**`Xmethod`** A penalty function for the exposure, i.e. penalty function when regressing Y onto X. Options are "lasso", "alasso","gglasso", and "SGL" (default).
**`Ymethod`** A penalty function for the outcome, i.e. penalty function when regressing X onto Y. Options are "lasso", "alasso","gglasso", "SGL", and "OLS" (default).
**`init.method`**         : Initialization method. Options are "lasso", "OLS", and "SVD" (default).
**`X.groupidx`**          : A vector of length \eqn{p} that indicates grouping structure of exposure \eqn{X}.
**`Y.groupidx`**          : A vector of length \eqn{q} that indicates grouping structure of outcome \eqn{Y}.
**`standardize `**        : A logical flag for exposure \eqn{X} and outcome \eqn{Y} standardization, prior to fitting the model.
**`max.iter`**            : A maximum number of iterations of SparseCCA. The default is $100$.
**`conv`**                : A tolerance value for convergence \eqn{epsilon} of SparseCCA. The default is $10e-2$.

4. Input parameters associated permutation test for AclustsCCA:
**`maxnum`** A maximal total number of permutations across all the clusters.
**`maxB`** A maximal number of permutations for a single cluster.
**`permute.tmp.filepath`** Filepath to save intermittent permutation results.
**`permute`** A logical flag for whether to run permutation test or not.
**`nthread`** A number of threads to parallelize permutation test and implementation of SparseCCA across all the clusters.
**`FDR.thresh`** FDR threshold. The default is $0.05$.

## How to implement AclustsCCA

```{r, eval=F}
data(annot) # row: CpG sites
data.list <- generate.data(n=500)

DATA.X <- data.list$DATA.X # row: subjects (n), column: Metals (p)
DATA.Y <- data.list$DATA.Y # row: subjects (n), column: CpG sites (q)


dist.type <- "spearman"
Aclust.method <-"average"
thresh.dist <-0.2
max.dist <-1000
bp.thresh.dist <-999

Xmethod <- "lasso"
Ymethod <- "OLS"
maxB <- 300
nthread <- 2

AclustsCCA.result <- AclustsCCA(X=DATA.X,
                                Y=DATA.Y,
                                clusters.list=NULL,
                                annot=annot,
                                # parameters for A-clustering
                                dist.type = dist.type,
                                Aclust.method = Aclust.method,
                                thresh.dist = thresh.dist,
                                max.dist = max.dist,
                                bp.thresh.dist = bp.thresh.dist,
                                # parameters for SparseCCA
                                Xmethod=Xmethod,
                                Ymethod=Ymethod,
                                # parameters for permutation test for AclustsCCA
                                maxB=maxB,
                                nthread=nthread)                         
```

## Suggestions on how to run AclustsCCA

The framework of `AclustsCCA` consists of two parts
1. Implement A-clustering on DNA methylation data
2. Implement SparseCCA on each cluster identified by A-clustering
 - When implementing SparseCCA, partial residuals are used to adjust for potential confounders
 - For statistical inference, permutation test is performed

All of the above procedures can be implemented at once using `AclustsCCA` function. Among these steps, permutation test is definitely a part that takes the most computational time to run and requires attention when running.

Therefore, I personally suggest running each part separately to save computational time and memory.
 
1. Implement A-clustering and save it

A-clustering is implemented to identify cluster and this part have to be ran only once. I personally suggest to run this part separately and save it for future use.

```{r,eval=F}
# Implement A-clustering
all.clusters.list <- assign.to.clusters(betas = t(DATA.Y), 
                                        annot = annot,
                                        dist.type = dist.type,
                                        method = Aclust.method,
                                        thresh.dist = thresh.dist,
                                        bp.thresh.dist = bp.thresh.dist,
                                        max.dist = max.dist)
# AclustsCCA only considers clusters with at least two probes
clusters.list <- all.clusters.list[sapply(all.clusters.list,length)!=1]
```

2. Obtain partial residuals to adjust for potential confounders

When implementing SparseCCA, partial residuals are used to adjust for potential confounders. Again, computing partial residuals have to be ran only once. I personally suggest to run this part separately and save it for future use.

```{r,eval=F}
X.resid <- partial.residual(data=DATA.X,Z=Z,nthread=nthread)
Y.resid <- partial.residual(data=DATA.Y,Z=Z,nthread=nthread)
```

3. Implement SparseCCA and permutation test on each cluster identified by A-clustering

As list of clusters are provided and partial residuals are computed, `AclustsCCA` will only run SparseCCA on each cluster identified by A-clustering.

```{r,eval=F}
AclustsCCA.result <- AclustsCCA(X=X.resid,
                                Y=Y.resid,
                                clusters.list=clusters.list,
                                # parameters for SparseCCA
                                Xmethod=Xmethod,
                                Ymethod=Ymethod,
                                # parameters for permutation test for AclustsCCA
                                maxB=maxB,
                                permute=T,
                                nthread=3) 

```
